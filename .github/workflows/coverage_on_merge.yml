name: Structured Jest Coverage and Test Summary

on:
  push:
    branches:
      - main

jobs:
  coverage-report:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    steps:
      - name: Checkout main
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Run Jest and extract full structured JSON
        run: |
          echo "ðŸ§ª Running Jest with coverage..."
          OUTPUT=$(npx jest --coverage 2>&1 | tee jest.log)

          echo "ðŸ“¦ Parsing test summary..."

          # Extract test summary block
          TEST_SUMMARY=$(awk '/Test Suites:/, /Ran all test suites/' jest.log)

          # Initialize summary fields
          TEST_SUITES=$(echo "$TEST_SUMMARY" | grep "Test Suites:" | sed 's/^Test Suites:[[:space:]]*//')
          TESTS=$(echo "$TEST_SUMMARY" | grep "^Tests:" | sed 's/^Tests:[[:space:]]*//')
          SNAPSHOTS=$(echo "$TEST_SUMMARY" | grep "^Snapshots:" | sed 's/^Snapshots:[[:space:]]*//')
          TIME=$(echo "$TEST_SUMMARY" | grep "^Time:" | sed 's/^Time:[[:space:]]*//')

          # Check if any suite/test failed
          BUILD_ERROR="false"
          echo "$TEST_SUITES" | grep -q "failed" && BUILD_ERROR="true"
          echo "$TESTS" | grep -q "failed" && BUILD_ERROR="true"

          echo "ðŸ“¦ Parsing coverage table..."

          # Extract coverage table block
          awk '/^[-]+[|][-]+/,/^[-]+[|][-]+/' jest.log > coverage_table.txt

          # Skip first and last line (table border), parse the rows
          tail -n +2 coverage_table.txt | head -n -1 > coverage_rows.txt

          echo "[" > coverage_array.json
          FIRST=1
          while IFS= read -r line; do
            CLEAN=$(echo "$line" | tr -d '|' | awk '{$1=$1; print}')
            FILE=$(echo "$CLEAN" | awk '{print $1}')
            STMT=$(echo "$CLEAN" | awk '{print $2}')
            BRANCH=$(echo "$CLEAN" | awk '{print $3}')
            FUNC=$(echo "$CLEAN" | awk '{print $4}')
            LINE_COV=$(echo "$CLEAN" | awk '{print $5}')
            UNCOVERED=$(echo "$line" | awk -F '|' '{print $6}' | sed 's/^[[:space:]]*//')

            [ "$FIRST" -eq 0 ] && echo "," >> coverage_array.json
            FIRST=0

            jq -n \
              --arg file "$FILE" \
              --arg stm "$STMT" \
              --arg br "$BRANCH" \
              --arg fn "$FUNC" \
              --arg ln "$LINE_COV" \
              --arg unc "$UNCOVERED" \
              '{file: $file, statements: $stm, branches: $br, functions: $fn, lines: $ln, uncovered_lines: $unc}' >> coverage_array.json
          done < coverage_rows.txt
          echo "]" >> coverage_array.json

          echo "ðŸ“Š Final Structured JSON:"
          jq -n \
            --arg build_error "$BUILD_ERROR" \
            --arg test_suites "$TEST_SUITES" \
            --arg tests "$TESTS" \
            --arg snapshots "$SNAPSHOTS" \
            --arg time "$TIME" \
            --slurpfile coverage test_coverage coverage_array.json \
            '{
              build_error: ($build_error == "true"),
              test_summary: {
                test_suites: $test_suites,
                tests: $tests,
                snapshots: $snapshots,
                time: $time
              },
              test_coverage: $test_coverage
            }'
